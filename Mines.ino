#include <Arduboy2.h>
Arduboy2 arduboy;
/*=========================================================
                         位图
  =========================================================*/
//HWT 作者信息 请勿删除
const uint8_t HWT[] PROGMEM = {0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x06, 0x33, 0x3c, 0x12, 0x8b, 0xe0, 0x89, 0x44, 0x42, 0x09, 0x49, 0x24, 0x12, 0x88, 0x80, 0x89, 0x44, 0x99, 0x02, 0x49, 0x3c, 0x1e, 0x88, 0x8c, 0x8f, 0x44, 0x99, 0x04, 0x49, 0x24, 0x12, 0xa8, 0x8c, 0x89, 0x54, 0x42, 0x08, 0x49, 0x24, 0x12, 0x50, 0x80, 0x89, 0x28, 0x66, 0x0f, 0x33, 0xbc, 0x12, 0x50, 0x80, 0xe9, 0x28, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//社会核心价值观
const uint8_t CSV[] PROGMEM = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfb,0xef,0xff,0x7f,0xef,0x9f,0xfd,0xff,0xde,0xff,0xbd,0xff,0xe0,0x7f,0xff,0xff,0xff,0xef,0xfe,0xbf,0xef,0xdf,0xfe,0xff,0xde,0xff,0x80,0x08,0x2f,0x7f,0xff,0xff,0xe1,0xef,0xfd,0xdf,0xec,0x01,0xfe,0x7f,0xbd,0x7f,0x7d,0xff,0xab,0x7f,0xff,0xff,0xfd,0xef,0xfb,0xef,0x83,0xbf,0xf6,0xff,0xbb,0xbf,0x7d,0xfb,0xab,0x7f,0xff,0xff,0xfb,0x00,0xf7,0xf7,0xef,0x7f,0xf7,0xff,0x37,0xde,0x60,0x3d,0x6b,0x7f,0xff,0xff,0xfb,0xef,0xc8,0x08,0xce,0xf7,0xb7,0xee,0xaf,0xe5,0x6f,0xbd,0x6b,0x7f,0xff,0xf8,0x31,0xef,0xff,0xfd,0xc6,0x07,0xb7,0xf7,0x9b,0xaf,0x60,0x3e,0xeb,0x78,0x3f,0xff,0xea,0xef,0xff,0xff,0xab,0xef,0xb7,0xfb,0xbb,0xbf,0x6f,0xbe,0xeb,0x7f,0xff,0xff,0xfb,0xef,0xe0,0x03,0xaf,0xdb,0xb7,0xfb,0xbb,0xbf,0x60,0x3d,0x6b,0x7f,0xff,0xff,0xfb,0xef,0xfe,0xff,0xef,0x33,0x77,0xfb,0xbb,0xbf,0x6f,0xbd,0xa9,0x7f,0xff,0xff,0xfb,0xef,0xfd,0xdf,0xec,0xef,0xf7,0xef,0xbb,0xbf,0x60,0x3d,0xb5,0xff,0xff,0xff,0xfb,0xef,0xfb,0xef,0xef,0xdf,0xf7,0xef,0xbb,0xbf,0x6f,0xbb,0xed,0xdf,0xff,0xff,0xfa,0x00,0x70,0x07,0xef,0x27,0xf7,0xef,0xb7,0xbf,0x6f,0xbf,0xdd,0xdf,0xff,0xff,0xfb,0xff,0xfb,0xf7,0xe8,0xfb,0xf8,0x1f,0xaf,0xbf,0x00,0x0f,0x3e,0x3f,0xff,0xff,0xdf,0xff,0xff,0xff,0xff,0xfd,0xff,0xfb,0xff,0xff,0xff,0xef,0xff,0xbd,0xff,0xf0,0x00,0x21,0x80,0xe0,0x03,0xfe,0xff,0xfd,0xff,0xfc,0x0f,0xc7,0xfd,0xbd,0xbf,0xf7,0xff,0xbd,0xbe,0xef,0xfb,0xfe,0xff,0xfd,0xfe,0x0d,0xec,0x3f,0xfe,0x85,0x7f,0xf4,0x01,0x7d,0xbe,0xef,0xfb,0xc0,0x03,0x00,0x02,0xed,0xef,0xbf,0xfe,0xbc,0xff,0xff,0xff,0xfd,0x80,0xe0,0x03,0xfe,0xff,0xef,0xde,0xec,0x0f,0xb8,0x1f,0xbd,0xdf,0xfe,0x03,0xe1,0xf7,0xef,0x7f,0xfe,0xff,0xef,0xde,0x0d,0xec,0x03,0xdf,0xa5,0xdf,0xfe,0xfb,0xef,0xf7,0xef,0x7f,0xfe,0xff,0xef,0xbe,0xed,0xef,0xbb,0xd8,0x9a,0x3f,0xfe,0x03,0xef,0x00,0x60,0x01,0xe0,0x07,0xf7,0xbe,0xed,0xef,0xbb,0xde,0xf7,0xff,0xff,0xff,0xe1,0x77,0x6f,0xbf,0xfe,0xff,0xf7,0x7e,0xec,0x0f,0x1b,0xde,0xc0,0x7f,0xfc,0x01,0xfd,0x77,0x6f,0xbf,0xfe,0xff,0xfb,0x7e,0x0d,0xee,0xab,0xde,0xdf,0x7f,0xfd,0xdd,0xfd,0x00,0x6f,0xdf,0xfe,0xff,0xfc,0xfe,0xed,0xee,0xab,0xde,0xdf,0x7f,0xfc,0x01,0xfd,0xf7,0xed,0xee,0xfe,0xff,0xfb,0x3f,0xfb,0xed,0xbb,0xde,0x80,0x7f,0xfd,0xdd,0xed,0xf6,0xeb,0xf6,0xfe,0xff,0xf7,0xdf,0xfb,0xef,0xb8,0x1e,0x5f,0x7f,0xfc,0x01,0xf5,0x00,0x67,0xf8,0x80,0x01,0xcf,0xe3,0xf7,0xaf,0xbb,0xde,0xdf,0x7f,0xfd,0xfd,0xfb,0xff,0x6f,0xfe,0xff,0xff,0x3f,0xf7,0xef,0xdf,0xbf,0xff,0xc0,0x7f,0xff,0xbf,0xff,0xbf,0xff,0xff,0xef,0xbf,0xff,0x7f,0xff,0xff,0xfe,0xff,0xfb,0xff,0xff,0xbf,0xff,0xbf,0xe0,0x01,0xef,0xbf,0xf7,0x3f,0x00,0x0e,0xfe,0xfd,0xfb,0xff,0xff,0x7f,0xff,0xbf,0xff,0x7f,0xc1,0x03,0xf7,0x7f,0xfb,0xff,0x7e,0xfe,0x77,0xff,0xfc,0x00,0xf0,0x00,0xf7,0x77,0xb6,0xef,0xf7,0x7f,0xfb,0xff,0xb0,0x1f,0x77,0x7f,0xfd,0xfe,0xf7,0xbe,0xfb,0x77,0xfe,0xff,0xef,0xbf,0xfb,0xfd,0xfe,0xfb,0xef,0xbf,0xfd,0xfe,0xf7,0xbe,0xfb,0x77,0xe0,0x07,0xef,0xbf,0xfb,0xfe,0xfe,0xfc,0xc0,0x1f,0xfc,0x00,0xf7,0xbe,0xfb,0x6f,0xfe,0xff,0xdd,0xdf,0xbb,0xff,0xde,0xfe,0xff,0xdf,0xfd,0xfe,0xf7,0xbe,0xff,0x7f,0x80,0x01,0xbd,0xe3,0xb8,0x1f,0xa0,0x0f,0xbf,0xff,0xfd,0xfe,0xf0,0x00,0xc0,0x00,0xff,0xdf,0x7b,0xf7,0xbb,0xff,0xbd,0xff,0x60,0x3f,0xfc,0x00,0xf7,0xbe,0xff,0x7f,0xc0,0x03,0xfb,0xff,0xbb,0xff,0x7d,0xfe,0xef,0xbf,0xfd,0xfe,0xf7,0xbe,0xff,0x7f,0xfb,0xdf,0xf7,0xff,0xbb,0xfc,0x7b,0xb8,0xef,0xbf,0xfd,0xfe,0xf7,0xbe,0xff,0x7f,0xfd,0xdf,0xef,0xbf,0xbb,0xff,0x7b,0xde,0xef,0xbf,0xfd,0xfe,0xf7,0xbe,0xff,0x7f,0xfd,0xdf,0xdf,0xdf,0xbb,0xff,0x77,0xde,0xef,0xbf,0xfc,0x00,0xf0,0x00,0xff,0x7f,0xff,0x5f,0x80,0x0f,0xbb,0xff,0x60,0x0e,0xe0,0x3f,0xfd,0xe0,0xf7,0xfe,0xf6,0x6f,0xfd,0xbf,0xdf,0xae,0x00,0x07,0x67,0xee,0x6d,0xbf,0xf8,0x1d,0xf0,0x00,0x76,0xef,0xfd,0xbf,0x7f,0xaf,0xde,0xff,0xef,0xff,0xbb,0xff,0xfd,0xbd,0xf7,0xff,0x40,0x2f,0xfd,0xbf,0xbf,0xb7,0xc0,0x04,0x00,0x0c,0x00,0x3f,0xfe,0xdb,0xf7,0xff,0x76,0xe0,0xdd,0xbb,0xb0,0x03,0xbf,0xff,0xef,0xff,0xef,0xff,0xf0,0x00,0x34,0x01,0x6f,0xdd,0xed,0xbb,0xf7,0xbf,0xbf,0xff,0xef,0xfe,0x00,0x7f,0xf7,0xbf,0x77,0xdf,0x60,0x3d,0xed,0xb7,0x37,0xbf,0x30,0x0f,0xc0,0x3f,0xef,0xff,0xff,0xbf,0xf7,0xdf,0x6f,0x5d,0xf5,0xb7,0xb0,0xb7,0x3f,0xff,0xdf,0xbc,0x00,0x3f,0xf8,0x00,0xf6,0x03,0x41,0x5d,0xf5,0xaf,0xb6,0xb6,0xb0,0x0f,0xaf,0x7f,0x6d,0xff,0xff,0x7f,0xf7,0xdf,0x6d,0x5b,0xf5,0xaf,0xb6,0xaf,0xbf,0xff,0xb7,0x7f,0xab,0xff,0xff,0x03,0xf7,0xd7,0x6d,0x6b,0xf5,0x9f,0xb6,0xaf,0xbf,0xff,0x7a,0xf8,0x00,0x1f,0xfe,0x7b,0xf7,0xdb,0x6d,0x77,0xfd,0xbf,0xa6,0xdf,0xb0,0x0e,0xfd,0xff,0xff,0xff,0xfd,0xb7,0xf4,0x01,0x61,0x6b,0xfd,0xbf,0x92,0xdb,0xb7,0xed,0xfa,0xfe,0x00,0xff,0xf3,0xcf,0xf7,0xff,0x6f,0x6b,0xfd,0xbf,0xb5,0xab,0xb7,0xef,0xe7,0x7e,0xfe,0xff,0xff,0x30,0x70,0x00,0x7d,0x5c,0x80,0x01,0xef,0x73,0xb0,0x0f,0x9f,0x8e,0x00,0xff,0xf8,0xfe,0xf7,0xff,0x7e,0xbd,0xff,0xff,0xde,0xfb,0xb7,0xec,0x7f,0xde,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
/*=========================================================
  变量
  =========================================================*/
byte x, y;
byte PX, PY; //玩家坐标
byte sx; //当前地图大小
byte KeyBack; //按键返回值
byte MAP[18][8]; //游戏地图
bool OMAP[18][8]; //遮挡地图
unsigned long GT; //游戏倒计时
/*
   0为空
   1-254 为距离
   255为地雷
*/
byte LEVEL = 1; //关卡
/*
     关卡 大小 雷数   难度
     1    8*8  10     16.625
     2    8*10 14     17.5
     3    8*12 18     18.75
     4    8*14 22     19.642
     5    8*16 26     20.312
     6    8*18 30     20.833

     大小:8*(8+(n-1)*2)
     雷数:10+(n-1)*4
*/
byte mines[2];
/*=========================================================
  只循环一次
  =========================================================*/
void setup() {
  arduboy.boot(); //启动
  Serial.begin(9600);

  for (int i = 63; i >= -8; i--) {
    arduboy.clear();
    arduboy.drawSlowXYBitmap(26, i, HWT, 72, 8, 1);
    arduboy.drawSlowXYBitmap(0, i + 8, CSV, 128, 64, 1);
    arduboy.display();
  }
  delay(1000);
  GenerateMap(); //生成地图
}
/*=========================================================
                     不停循环
  =========================================================*/
void loop() {
  key(); //按键扫描
  logic(); //逻辑
  draw(); //绘图
  //DEBUG();
}

/*=========================================================
  生成地图 和 初始化游戏
  =========================================================*/
void GenerateMap() {
  sx = 8 + (LEVEL - 1) * 2;
  PX = sx / 2.0;
  PY = 4;
  //清空地图
  for (y = 0; y < 8; y++) {
    for (x = 0; x < sx; x++) {
      MAP[x][y] = 0;
      OMAP[x][y] = true;
    }
  }
  //生成地雷
  mines[1] = 10 + (LEVEL - 1) * 4; //计算当前关卡要生成颗地雷
  for (mines[0] = 0; mines[0] < mines[1];) {
    //随机生成地雷坐标
    x = random(sx);
    y = random(8);
    if (MAP[x][y] == 0) {  //判断随机位置是否为地雷，是的话重新生成
      //  Serial.println(String("[ ") + x + String(" ] ") + String("[ ") + y + String(" ]"));
      MAP[x][y] = 255; //设置地雷
      mines[0]++;
    }
  }
  mines[0] = 0;
  //计算与雷的距离
  for (y = 0; y < 8; y++) {
    for (x = 0; x < sx; x++) {
      if (MAP[x][y] != 255) {
        //该位置不是雷，计算附近3*3有多少雷
        for (int my = -1; my < 2; my++) {
          for (int mx = -1; mx < 2; mx++) if (MAP[x + mx][y + my] == 255 && x + mx >= 0 && y + my >= 0 && x + mx < sx && y + my < 8) MAP[x][y]++;
        }
      }
    }
  }
  GT = millis() / 1000;
}
/*=========================================================
  按键扫描
  =========================================================*/
void key() {
  /*
      0  1  2  3  4  5
      ↑ ↓← →  A  B
  */
  KeyBack = 255;
  if (arduboy.pressed(UP_BUTTON)) KeyBack = 0;
  if (arduboy.pressed(DOWN_BUTTON)) KeyBack = 1;
  if (arduboy.pressed(LEFT_BUTTON)) KeyBack = 2;
  if (arduboy.pressed(RIGHT_BUTTON)) KeyBack = 3;
  if (arduboy.pressed(A_BUTTON)) KeyBack = 4;
  if (arduboy.pressed(B_BUTTON)) KeyBack = 5;
}
/*=========================================================
  绘图
  =========================================================*/
void draw() {
  arduboy.clear();
  byte x, y;
  arduboy.setCursor(0, 0);
  //显示扫雷地图
  mines[0] = 0;
  for (y = 0; y < 8; y++) {
    for (x = 0; x < sx; x++) {
      arduboy.setCursor(x * 6, y * 8);
      if (OMAP[x][y] == false || MAP[PX][PY] == 254) {
        if (MAP[x][y] == 255) {
          arduboy.print(F("^"));
        } else if (MAP[x][y] == 0) {
          arduboy.print(F("."));
        } else {
          if (MAP[x][y] != 254) arduboy.print(MAP[x][y]);
        }
      } else {
        arduboy.print(F("+"));
        mines[0]++;
      }
    }
  }
  //判定是否通关
  if (mines[0] == mines[1]) win();
  //显示状态栏
  arduboy.drawLine(108, 0, 108, 64, 1);
  arduboy.setCursor(110, 24);
  arduboy.print(mines[0]);
  arduboy.setCursor(116, 32);
  arduboy.print(F("/"));
  arduboy.setCursor(110, 40);
  arduboy.print(mines[1]);
  //显示光标 以及状态栏表情
  arduboy.setCursor(PX * 6, PY * 8);
  if (MAP[PX][PY] == 254) {
    arduboy.print(F("*"));
    arduboy.setCursor(110, 0);
    arduboy.print(F(":("));
  } else {
    arduboy.print(F("@"));
    arduboy.setCursor(110, 0);
    arduboy.print(F(":)"));
  }
  //显示游戏剩余时间
  arduboy.setCursor(110, 8);
  arduboy.print(300 + GT - millis() / 1000);
  arduboy.display();
}
/*=========================================================
  DEBUG
  =========================================================*/
void DEBUG() {
  Serial.println("=======DEBUG=======");
  for (y = 0; y < 8; y++) {
    for (x = 0; x < sx; x++) {
      if (MAP[x][y] == 255) {
        Serial.print(F("X"));
      } else {
        Serial.print(MAP[x][y]);
      }
    }
    Serial.println();
  }
  Serial.println("=======OMAP=======");
  for (y = 0; y < 8; y++) {
    for (x = 0; x < sx; x++) {
      Serial.print(OMAP[x][y]);
    }
    Serial.println();
  }
  Serial.println();
  Serial.print(F(""));
  Serial.println();
}
/*=========================================================
  逻辑
  =========================================================*/
void logic() {
  //按键返回
  switch (KeyBack) {
    case 0:
      if (PY != 0) PY--;
      break;
    case 1:
      if (PY != 7) PY++;
      break;
    case 2:
      if (PX != 0) PX--;
      break;
    case 3:
      if (PX < sx - 1) PX++;
      break;
    case 4:
      OMAP[PX][PY] = false; //做标记 这个位置挖开了
      if (MAP[PX][PY] == 255) {
        MAP[PX][PY] = 254;
        fail();
      } else if (MAP[PX][PY] == 0) {
        BOOM();
      }
      break;
    case 5:
      break;
  }
  //判断是否超时
  if (millis() / 1000.0 >= GT + 300) fail(); //游戏超时 游戏结束
}
/*=========================================================
                  下一关
  =========================================================*/
void win() {
  arduboy.clear();                          //清空显存
  for (y = 0; y < 8; y++) {
    for (x = 0; x < sx; x += 3) {
      arduboy.setCursor(x * 6, y * 8);           //设置光标
      arduboy.print(F("WIN"));                 //打印 你赢了
      arduboy.display();                        //把画面显示在OLED上
      delay(10);
    }
  }
  delay(5000);
  if (LEVEL != 6) LEVEL++;
  GenerateMap();
}
/*=========================================================
                  失败
  =========================================================*/
void fail() {
  draw();
  delay(5000);
  GenerateMap();
}
/*=========================================================
  BOOM  炸开一片区域 通常程序会在空白时候调用
  =========================================================*/
void BOOM() {
SBOOM:
  MAP[PX][PY] = 253;
  bool Change = false;
  for (y = 0; y < 8; y++) {
    for (x = 0; x < sx; x++) {
      //开始遍历地图
      for (int my = -1; my < 2; my++) {
        for (int mx = -1; mx < 2; mx++) {
          if (x + mx >= 0 && y + my >= 0 && x + mx < sx && y + my < 8) { //防止内存越界
            if (MAP[x + mx][y + my] == 0 && MAP[x][y] == 253) {
              Change = true;
              MAP[x + mx][y + my] = 253;
            }
          }
        }
      }
    }
  }
  if (Change == true) goto SBOOM;
  for (y = 0; y < 8; y++) {
    for (x = 0; x < sx; x++) {
      if (MAP[x][y] == 253) {
        MAP[x][y] = 0;
        for (int my = -1; my < 2; my++) {
          for (int mx = -1; mx < 2; mx++) {
            if (x + mx >= 0 && y + my >= 0 && x + mx < sx && y + my < 8) { //防止内存越界
              OMAP[x + mx][y + my] = false;
            }
          }
        }
      }
    }
  }
}

